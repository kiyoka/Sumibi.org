#!/usr/local/bin/gosh
;;
;; "Sumibi" is an Ank kana kanji conversion system.
;;
;;   Copyright (C) 2002,2003,2004,2005 Kiyoka Nishyama
;;     $Date: 2005/06/12 13:02:08 $
;;
;; This file is part of Sumibi
;;
;; Sumibi is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;; 
;; Sumibi is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;; 
;; You should have received a copy of the GNU General Public License
;; along with Sumibi; see the file COPYING.
;;
;;
(use text.parse)
(use gauche.parseopt)
(use gauche.charconv)
(use srfi-1)
(use srfi-11)
(use srfi-13)
(use dbi)
(use gauche.collection)
(use util.list)
(use www.cgi)
(use text.tree)
(load "sumibi/sumibi-define.scm")
(load "sumibi/skkdict-load.scm")
(load "sumibi/corpus-load.scm")


;;
;;  'おこな' 'u' 等のSQL発行用リストを作成する。
;;
(define (sumibi-make-okurigana-pattern-list hiragana)
  (let ((okuri-pattern-list '()))
    (dotimes
     (i (- (string-length hiragana) 1 ))
     (let (
	   (kanji-part (substring hiragana 0 (+ i 1)))
	   (okuri-part (substring
			(romkan-kana->roman
			 (substring hiragana (+ i 1) (+ i 2)))
			0
			1))
	   (okuri-kana-part (substring hiragana (+ i 1) (string-length hiragana))))

       (when sumibi-debug
	     (begin
	       (display "kanji-part      = ") (display kanji-part) (newline)
	       (display "okuri-part      = ") (display okuri-part) (newline)
	       (display "okuri-kana-part = ") (display okuri-kana-part) (newline)))
       (set! okuri-pattern-list (cons
				 `(,kanji-part
				   ,okuri-part
				   ,okuri-kana-part)
				 okuri-pattern-list))))
    okuri-pattern-list))



;;
;; roman 文字列をかな文字列に変換する
;; もしかなに変換出来ない文字があれば、#f を返す
;;
(define (sumibi-roman->kana str)
  (let (
	(hiragana (romkan-roman->kana str)))

    (if (romkan-is-hiragana hiragana)
	hiragana
	#f)))

;;
;; 文節の読みから、候補となる単語を列挙する。
;;  引数:
;;   str    ... 文節文字列
;;   method ... メソッドを示すシンボル ( h k j など )
;;
;;  戻り値: 
;;   (
;;    (
;;      method   . ユーザー指定メソッド
;;      orig     . 検索文字列
;;      hiragana . ひらがなに変換した文字列
;;      katakana . カタカナに変換した文字列
;;      alpha    . アルファベットに変換した文字列
;;    )
;;    (
;;      単語ID
;;      (tango    . 単語文字列)
;;      (yomi     . 読み文字列)
;;      (okuri    . 送り文字列:一文字)
;;      (freq     . 頻度:回数)
;;   )
;;
(define (sumibi-lookup-candidate-bunsetu str method query)
  (let* (
	 (hiragana (sumibi-roman->kana str))
	 (katakana (if hiragana
		       (romkan-hiragana->katakana hiragana)
		       #f))
	 (okuri-pattern-list (if hiragana
				 (sumibi-make-okurigana-pattern-list hiragana)
				 '()))
	 (std-query      (format "SELECT id, tango, yomi, okuri, freq_base FROM word WHERE (yomi  = ~s AND okuri = '') "  str))
	 (yomi-query     
	  (if hiragana
	      (format "SELECT id, tango, yomi, okuri, freq_base FROM word WHERE (yomi  = ~s AND okuri = '') "  hiragana)
	      #f))
	 (hiragana-query 
	  (if hiragana
	      (format "SELECT id, tango, yomi, okuri, freq_base FROM word WHERE (tango = ~s AND okuri = '') "  hiragana)
	      #f))
	 (katakana-query
	  (if katakana
	      (format "SELECT id, tango, yomi, okuri, freq_base FROM word WHERE (tango = ~s AND okuri = '') "  katakana)
	      #f))

	 ;; かなに直した読みでマッチングする。
	 ;; または 元の英語綴のままで直接マッチングする
	 (okuri-query
	  (if (> 1 (length okuri-pattern-list))
	      #f
	      (string-append
	       "SELECT id, tango, yomi, word.okuri, word.freq_base FROM word RIGHT JOIN okuri USING ( okuri ) WHERE "
	       (string-join
		(map 
		 (lambda (x)
		   (format " (yomi = ~s AND okuri.okuri = ~s AND kana = ~s) " (car x) (cadr x) (caddr x)))
		 okuri-pattern-list)
		" OR "))))

	 (query-string 
	  (cond
	   ;; ひらがな固定
	   ((and (eq? method 'h) hiragana-query)
	    hiragana-query
	    )
	   ;; カタカナ固定
	   ((and (eq? method 'k) katakana-query)
	    katakana-query
	    )
	   (else
	    (string-append
	     "       ( " std-query " ) "
	     (if yomi-query
		 (string-append " UNION ( " yomi-query " ) ")
		 "")
	     (if katakana-query
		 (string-append " UNION ( " katakana-query " ) ")
		 "")
	     (if okuri-query
		 (string-append " UNION ( " okuri-query " ) ")
		 "")
	     ))))

	 (result
	  (map
	   (lambda (x)
	     `(
	       ,(list-ref x 0)
	       (tango    . ,(list-ref x 1))
	       (yomi     . ,(list-ref x 2))
	       (okuri    . ,(list-ref x 3))
	       (freq     . ,(list-ref x 4))))
	   (sumibi-select-query query 
				query-string
				"dsssd"
				))))

    (when sumibi-debug
	  (begin
	    (display (format "bunsetu = ~s" hiragana)) (newline)
	    (display (format "method  = ~S" method)) (newline)
	    (display (format "#search1# = ~s" query-string)) (newline)
	    (display "result1:")
	    (display result)
	    (newline)))
    `(
      ,(append
	`((method   . ,method))
	`((orig     . ,str))
	`((hiragana . ,hiragana))
	`((katakana . ,katakana))
	`((alpha    . ,str)))
      ,result)))


;;
;; 3つのNgramの結果から評価値を求める
;;
(define (sumibi-compute-pacent result-bigram-pre2 result-bigram-pre1 result-word result-bigram-post1 result-bigram-post2)
  (let* (
	 (result
	 (map
	  (lambda (x)
	    (let* (
		   (id   (car x))
		   (data (cdr x))
		   (relative0 (cdr (assq 'relative0 data)))
		   (okuri     (cdr (assq 'okuri     data)))
		   (pre2  (assv id result-bigram-pre2))
		   (pre1  (assv id result-bigram-pre1))
		   (post1 (assv id result-bigram-post1))
		   (post2 (assv id result-bigram-post2))
		   (total
		    (+
		     (*
		      (list-ref sumibi-evaluate-balance 0)
		      (if pre2
			  (cdr (assq 'relative-2 (cdr pre2)))
			  0))
		     (*
		      (list-ref sumibi-evaluate-balance 1)
		      (if pre1
			  (cdr (assq 'relative-1 (cdr pre1)))
			  0))
		     (*
		      (list-ref sumibi-evaluate-balance 2)
		      relative0)
		     (*
		      (list-ref sumibi-evaluate-balance 3)
		      (if post1
			  (cdr (assq 'relative1 (cdr post1)))
			  0))
		     (*
		      (list-ref sumibi-evaluate-balance 4)
		      (if post2
			  (cdr (assq 'relative2 (cdr post2)))
			  0))))
		   ;; 送りがながある単語の評価を落とす
		   (total 
		    (if (< 0 (string-length okuri))
			(* total sumibi-evaluate-okurigana)
			total)))

	      (cons
	       id
	       (append data
		       (if pre1
			   (cdr pre1)
			   '((relative-1 . 0)))
		       (if pre2
			   (cdr pre2)
			   '((relative-2 . 0)))
		       (if post1
			   (cdr post1)
			   '((relative1 . 0)))
		       (if post2
			   (cdr post2)
			   '((relative2 . 0)))
		       `((total . ,total))))))

	  result-word))

	 ;; 結果を、評価値の高い順にソートする
	 (result
	  (sort result
		(lambda (x y)
		  (>
		   (cdr (assq 'total x))
		   (cdr (assq 'total y)))))))
    
    result))
	

;;
;; 前後に2連鎖した単語候補から、全組合せの共起確率を求める
;;
(define (sumibi-compute-candidate-pacent-sub rensa-bunsetu query)

  ;; 総あたりのwhere句を生成する
  (define (make-souatari-where-exp id-list1 id-list2)
    (if (null? id-list2)
	""
	(string-join
	 (map
	  (lambda (x)
	    (format " (id_base = ~d  AND  id_m1 = ~d) " (car x) (cadr x)))
	  (cartesian-product-right
	   (list
	    id-list1
	    id-list2)))
	 " OR ")))


  ;; 共起頻度を集計し％で結果を求める
  (define (exec-bigram-search-pre id-list table-name where-exp key debug-message query)
    (let* (
	   (sum-query-string
	    (string-append "SELECT SUM(freq_base) FROM " table-name " WHERE " where-exp))
	   (_
	    (if (null? id-list)
		'((1))
		(sumibi-select-query query 
				     sum-query-string
				     "d")))
	   (sum-str (number->string (caar _)))
	   
	   (bigram-query-string
	    (string-append
	     "    SELECT id_base, SUM( " table-name ".freq_base ), " sum-str ", SUM( " table-name ".freq_base )/ " sum-str " ,word.tango, okuri "
	     "      FROM " table-name " JOIN word ON id_base = word.id "
	     "      WHERE " where-exp
	     "    GROUP BY id_base ;"
	     ))
	   
	   (_
	    (when sumibi-debug
		  (begin
		    (display (format "~a = ~s" debug-message bigram-query-string)) (newline))))
	   
	   (result-bigram
	    (if (null? id-list)
		'()
		(map
		 (lambda (x)
		   `(
		     ,(list-ref x 0)
		     (freq1     . ,(list-ref x 1))
		     (sum1      . ,(list-ref x 2))
		     (,(string->symbol key) . ,(list-ref x 3))
		     (tango     . ,(list-ref x 4))
		     (okuri     . ,(list-ref x 5))))
		 (sumibi-select-query query 
				      bigram-query-string
				      "ddddss")))))))

  ;; 共起頻度を集計し％で結果を求める
  (define (exec-bigram-search-post id-list table-name where-exp key debug-message query)
    (let* (
	   (sum-query-string
	    (string-append "SELECT SUM(freq_base) FROM " table-name " WHERE " where-exp))
	   (_
	    (if (null? id-list)
		'((1))
		(sumibi-select-query query 
				     sum-query-string
				     "d")))
	   (sum-str (number->string (caar _)))
	   
	   (bigram-query-string
	    (string-append
	     "    SELECT id_m1, SUM( " table-name ".freq_base ), " sum-str ", SUM( " table-name ".freq_base )/ " sum-str " ,word.tango, okuri "
	     "      FROM " table-name " JOIN word ON id_m1 = word.id "
	     "      WHERE " where-exp
	     "    GROUP BY id_base ;"
	     ))
	   
	   (_
	    (when sumibi-debug
		  (begin
		    (display (format "~a = ~s" debug-message bigram-query-string)) (newline))))
	   
	   (result-bigram
	    (if (null? id-list)
		'()
		(map
		 (lambda (x)
		   `(
		     ,(list-ref x 0)
		     (freq1     . ,(list-ref x 1))
		     (sum1      . ,(list-ref x 2))
		     (,(string->symbol key) . ,(list-ref x 3))
		     (tango     . ,(list-ref x 4))
		     (okuri     . ,(list-ref x 5))))
		 (sumibi-select-query query 
				      bigram-query-string
				      "ddddss")))))))

  (let* (
	 ;; 二つ前の単語の候補ID
	 (id-list-pre2
	  (map
	   (lambda (x)
	     (car x))
	   (cadr (list-ref rensa-bunsetu 0))))

	 ;; 一つ前の単語の候補ID
	 (id-list-pre1
	  (map
	   (lambda (x)
	     (car x))
	   (cadr (list-ref rensa-bunsetu 1))))

	 ;; 注目位置の単語候補
	 (id-list
	  (map
	   (lambda (x)
	     (car  x))
	   (cadr (list-ref rensa-bunsetu 2))))

	 ;; 一つ後ろの単語の候補ID
	 (id-list-post1
	  (map
	   (lambda (x)
	     (car x))
	   (cadr (list-ref rensa-bunsetu 3))))

	 ;; 二つ後ろの単語の候補ID
	 (id-list-post2
	  (map
	   (lambda (x)
	     (car x))
	   (cadr (list-ref rensa-bunsetu 4))))


	 ;; 単語の候補IDを全て総あたり検索するWHERE句
	 (where-exp
	  (string-join
	   (map
	    (lambda (x)
	      (format " id = ~d " x))
	    id-list)
	   " OR "))
	 (where-exp-pre1
	  (make-souatari-where-exp
	   id-list id-list-pre1))
	 (where-exp-pre2
	  (make-souatari-where-exp
	   id-list id-list-pre2))
	 (where-exp-post1
	  (make-souatari-where-exp
	   id-list-post1 id-list))
	 (where-exp-post2
	  (make-souatari-where-exp
	   id-list-post2 id-list))

	 ;; 頻度総計を求める
	 (sum-query-string
	  (string-append "SELECT SUM(freq_base) FROM word WHERE " where-exp))
	 (_
	  (sumibi-select-query query 
			       sum-query-string
			       "d"))
	 (sum-str (number->string (caar _)))

	 (query-string
	  (string-append
	   "    SELECT id, tango, yomi, okuri, word.freq_base, " sum-str " ,word.freq_base / " sum-str " AS relative0 "
	   "      FROM word "
	   "      WHERE " where-exp 
	   ))

	 (_
	  (when sumibi-debug
		(begin
		  (display (format "#search2# = ~s" query-string)) (newline))))
		  
	 (result-word
	  (map
	   (lambda (x)
	     `(
	       ,(list-ref x 0)
	       (tango     . ,(list-ref x 1))
	       (yomi      . ,(list-ref x 2))
	       (okuri     . ,(list-ref x 3))
	       (freq0     . ,(list-ref x 4))
	       (sum0      . ,(list-ref x 5))
	       (relative0 . ,(list-ref x 6))))

	   (sumibi-select-query query 
				query-string
				"dsssddd")))


	 ;; 頻度総計を求める(pre1)
	 (result-bigram-pre1
	  (exec-bigram-search-pre id-list-pre1 "bigram" where-exp-pre1 "relative-1" "#search-pre1" query))

	 ;; 頻度総計を求める(pre2)
	 (result-bigram-pre2
	  (exec-bigram-search-pre id-list-pre2 "skip_bigram" where-exp-pre2 "relative-2" "#search-pre2" query))

	 ;; 頻度総計を求める(post1)
	 (result-bigram-post1
	  (exec-bigram-search-post id-list-post1 "bigram" where-exp-post1 "relative1" "#search-post1" query))

	 ;; 頻度総計を求める(post2)
	 (result-bigram-post2
	  (exec-bigram-search-post id-list-post2 "skip_bigram" where-exp-post2 "relative2" "#search-post2" query)))

    (when sumibi-debug
	  (begin
	    (display "result-pre2:")   (pretty-print result-bigram-pre2)   (newline)
	    (display "result-pre1:")   (pretty-print result-bigram-pre1)   (newline)
	    (display "result-base:")   (pretty-print result-word)          (newline)
	    (display "result-post1:")  (pretty-print result-bigram-post1)  (newline)
	    (display "result-post2:")  (pretty-print result-bigram-post2)  (newline)
	    ))

    (sumibi-compute-pacent
     result-bigram-pre2
     result-bigram-pre1
     result-word
     result-bigram-post1
     result-bigram-post2)))



;;
;; 前後に2連鎖した単語候補から、全組合せの共起確率を求める
;;
(define (sumibi-compute-candidate-pacent rensa-bunsetu query)
  (when sumibi-debug
	(begin
	  (display "#2#:")
	  (pretty-print rensa-bunsetu)
	  (newline)))
  (let* (
	;; 注目している単語の候補ID
	 (center(list-ref rensa-bunsetu 2))

	 (id-list
	  (map
	   (lambda (x)
	     (car x))
	   (cadr center))))

    (if (null? id-list)
	(begin
	  (if sumibi-debug
	      (begin
		(display "#kouho none#: ")
		(write (list-ref rensa-bunsetu 2))
		(newline)))
	  (list-ref rensa-bunsetu 2))
	
	;; 候補が存在するものについて実際に計算する
	`(
	  ,(car (list-ref rensa-bunsetu 2))
	  ,(sumibi-compute-candidate-pacent-sub rensa-bunsetu query)))))


;;
;; 変換候補リストを作成する
;;  連鎖する単語の評価値を求め、一番評価値の高い候補に並べる
;;
(define (sumibi-make-henkan-kouho kouho-list query)
  (let* (
	 ;; ダミーの文節データ
	 (dummy-bunsetu
	  '(
	    (
	     (orig     . #f)
	     (hiragana . #f))
	    (
	     (0 ;; id
	      (tango . "")
	      (yomi  . "")
	      (okuri . "")
	      (freq  . 0)
	      ))
	    ))

	 ;; スライドデータ1:先頭の単語の前にゼロ個ダミーを結合したもの
	 (kouho-list-pre0
	  (append
	   kouho-list
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)))

	 ;; スライドデータ1:先頭の単語の前に１つダミーを結合したもの
	 (kouho-list-pre1
	  (append
	   (list dummy-bunsetu)
	   kouho-list
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)))

	 ;; スライドデータ2:先頭の単語の前に２つダミーを結合したもの
	 (kouho-list-pre2
	  (append
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   kouho-list
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)))

	 ;; スライドデータ2:先頭の単語の前に３つダミーを結合したもの
	 (kouho-list-pre3
	  (append
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   kouho-list
	   (list dummy-bunsetu)))

	 ;; スライドデータ2:先頭の単語の前に４つダミーを結合したもの
	 (kouho-list-pre4
	  (append
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   kouho-list))

	 ;; bigram, skip-bigram を使って可能性のある共起頻度を全パターン求める
	 (point-result
	  (map
	   (lambda (rensa-bunsetu)
	     (sumibi-compute-candidate-pacent rensa-bunsetu query))
	   (zip
	    kouho-list-pre4
	    kouho-list-pre3
	    kouho-list-pre2
	    kouho-list-pre1
	    kouho-list-pre0)))

	 ;; 前後 ２個づつの要素を削除する
	 (point-result
	  (take*
	   (drop* point-result 2)
	   (- (length point-result) 4))))

    (when sumibi-debug
	  (begin
	    (display "point-result:")
	    (pretty-print point-result)
	    (newline)))


    point-result))
	     

;;
;; 完成した文節を返す。
;;
(define (sumibi-output-henkan-kouho tango-info kouho-info)

  (define (is-kigou str)
    (not
     (rxmatch #/^[a-zA-Z0-9]+$/ str)))

  ;; 一番評価値の高い順に完成した文節を返す
  (map
   (lambda (x)
     (let (
	   (hiragana (cdr (assq 'hiragana tango-info)))
	   (orig     (cdr (assq 'orig tango-info)))
	   (tango    (cdr (assq 'tango   x)))
	   (okuri    (cdr (assq 'okuri   x)))
	   (yomi     (cdr (assq 'yomi    x))))
    
       `(j
	 ,(if (or hiragana (is-kigou orig))
	       (if (< 0 (string-length okuri))
		   (let ((okuri-string
			  (substring hiragana
				     (string-length yomi)
				     (+ (string-length yomi)
					(- (string-length hiragana) (string-length yomi))))))
		     (string-append
		      tango
		      okuri-string))
		   tango)
	       orig)
	 0)))
   kouho-info))


;;
;; 変換する。
;;  一番評価値の高い順に完成した文節を返す。
;;
(define (sumibi-output-henkan-kouho-list henkan-kouho-list)

  (map
   (lambda (bunsetu)
     (let (
	   ;; 単語情報
	   (tango-info (car  bunsetu))
	   (kouho-info (cadr bunsetu)))
       
       (when sumibi-debug
	     (begin
	       (display "#5#")
	       (write tango-info)
	       (newline)
	       (display "#6#")
	       (write kouho-info)
	       (newline)))
       
       (let* (
	      (method   (cdr (assq 'method tango-info)))
	      (orig     (cdr (assq 'orig tango-info)))
	      (hiragana (cdr (assq 'hiragana tango-info)))
	      (katakana (cdr (assq 'katakana tango-info)))
	      (alpha    (cdr (assq 'alpha    tango-info)))
	 
	      ;; 候補値の高い順に完成した文節を返す。
	      (j-kouho  (sumibi-output-henkan-kouho tango-info kouho-info))
	      (_index   0)

	      ;; 
	      (j-etc-kouho
	       (append
		;; 候補値の高い順に完成した文節を返す。
		j-kouho

		;; 必須項目 ひらがな、カタカナ、アルファベットをリストの最後に追加する。
		(filter-map
		 (lambda (x)
		   x)
		 (case method
		   ('h
		    (list
		     (if hiragana        `(h ,hiragana) #f)
		     (if katakana        `(k ,katakana) #f)
		     (if alpha           `(l ,alpha   ) #f)))
		   ('k
		    (list
		     (if katakana        `(k ,katakana) #f)
		     (if hiragana        `(h ,hiragana) #f)
		     (if alpha           `(l ,alpha   ) #f)))
		   (else
		    (list
		     (if hiragana        `(h ,hiragana) #f)
		     (if katakana        `(k ,katakana) #f)
		     (if alpha           `(l ,alpha   ) #f))))))))

	 ;; 候補の最後に、index番号を付ける
	 (map
	  (lambda (x)
	    (begin0
	     (append x (list _index))
	     (set! _index (+ 1 _index))))
	  j-etc-kouho))))

   henkan-kouho-list))

	
;;
;; 文章文字列を変換する。
;;
(define (sumibi-convert-sentence str query)
  (let* (
	 ;; 文節リスト ( 一つ一つの文節は、全てローマ字のまま )
	 (bunsetu-list (string-split str #/\s+/))

	 (_
	  (when sumibi-debug
		(display "#0#")
		(write bunsetu-list)
		(newline)))

	 ;; 候補を検索する
	 (lookup-list
	  (map
	   (lambda (x)
	     (let* (
		    (tango x)
		    (match (rxmatch #/\.([a-zA-Z0-9]+)$/ x))
		    (method (if match
				(begin
				  (set! tango (rxmatch-before match))
				  (string->symbol (match 1)))
				#f)))
	       (sumibi-lookup-candidate-bunsetu tango method query)))
	   bunsetu-list))
	 (_
	  (when sumibi-debug
		(begin
		  (display "#1#")
		  (write lookup-list)
		  (newline))))

	 ;; 評価値順の候補リストを求める
	 (henkan-kouho-list (sumibi-make-henkan-kouho lookup-list query))

	 ;; 変換候補リストを完成させて返す。
	 (complete-henkan-kouho-list (sumibi-output-henkan-kouho-list henkan-kouho-list)))

    ;; 結果を返す
    complete-henkan-kouho-list))


;; 一行コマンドを実行する
(define (sumibi-do-command str query)
  (let* (
	 (words (string-split str #/\s+/))
	 (command (car words))
	 (args (cdr words))
	 (args-string (string-join
		       args
		       " ")))
    (case (string->symbol command)
      ('convertsexp
       (let (
	     (result
	      (sumibi-convert-sentence args-string query)))
	 (list
	  "ok"
	  result)
	 ))
      (else
       ;; 未定義のコマンドが指定された場合
       nil))))


;; Main -------------------------------------------------------
(define (main args)

  (define docstrings
    `(
      ,(string-append "sumibi " sumibi-version)
      ""
      " Usage:"
      "	    sumibi [switches] [dictionary-file]"
      ""
      " Switches:"
      "     -h ... Display this help message."
      ))

  (define (display-help)
    (for-each
     (lambda (docstring)
       (print docstring))
     docstrings)
    (exit 4))

  (let* (
	 (connection (dbi-make-connection driver 
					  sumibi-sumibidb-user
					  sumibi-sumibidb-password
					  sumibi-sumibidb-name))
	 (query (dbi-make-query connection))

	 ;; 第一引数を捨てる
	 (_ (cdr args))
	 
	 ;; optionのチェック
	 (_ (parse-options
	     _
	     (
	      ("h" () (display-help))))))

    ;; 標準入出力による対話式プロトコル
    (port-for-each
     (lambda (x)
       (let ((result (sumibi-do-command x query)))
	 (when (not result)
	       (exit 0))
	 (for-each
	  (lambda (line)
	    (display line)
	    (newline))
	  result)
	 (newline)
	 (flush (current-output-port))))
     read-line))

  (exit 0))
