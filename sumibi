#!/usr/local/bin/gosh
;;
;; "Sumibi" is a Ank kana kanji convert tool.
;;
;;   Copyright (C) 2002,2003,2004 Kiyoka Nishyama
;;     $Date: 2005/01/07 16:47:42 $
;;
;; This file is part of Sumibi
;;
;; Sumibi is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;; 
;; Sumibi is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;; 
;; You should have received a copy of the GNU General Public License
;; along with Sumibi; see the file COPYING.
;;
;;
(use text.parse)
(use gauche.parseopt)
(use gauche.charconv)
(use slib)
(use srfi-1)
(use srfi-11)
(use srfi-13)
(use dbi)
(use gauche.collection)
(use util.list)
(require 'pretty-print)
(require 'collect)
(load "sumibi/skkdict-load.scm")
(load "sumibi/corpus-load.scm")
(load "sumibi/sumibi-define.scm")


;;
;;  'おこな' 'u' 等のSQL発行用リストを作成する。
;;
(define (sumibi-make-okurigana-pattern-list hiragana)
  (let ((okuri-pattern-list '()))
    (dotimes
     (i (- (string-length hiragana) 1 ))
     (let (
	   (kanji-part (substring hiragana 0 (+ i 1)))
	   (okuri-part (substring
			(romkan-kana->roman
			 (substring hiragana (+ i 1) (+ i 2)))
			0
			1))
	   (okuri-kana-part (substring hiragana (+ i 1) (string-length hiragana))))

       (when sumibi-debug
	     (begin
	       (display "kanji-part      = ") (display kanji-part) (newline)
	       (display "okuri-part      = ") (display okuri-part) (newline)
	       (display "okuri-kana-part = ") (display okuri-kana-part) (newline)))
       (set! okuri-pattern-list (cons
				 `(,kanji-part
				   ,okuri-part
				   ,okuri-kana-part)
				 okuri-pattern-list))))
    okuri-pattern-list))



;;
;; roman 文字列をかな文字列に変換する
;; もしかなに変換出来ない文字があれば、#f を返す
;;
(define (sumibi-roman->kana str)
  (let (
	(hiragana (romkan-roman->kana str)))

    (if (romkan-is-hiragana hiragana)
	hiragana
	#f)))

;;
;; 文節の読みから、候補となる単語を列挙する。
;;  戻り値: 
;;   (
;;    (
;;      orig     . 検索文字列
;;      hiragana . ひらがなに変換した文字列 ( #f もあり得る )
;;    )
;;    (
;;      単語ID
;;      (tango    . 単語文字列)
;;      (yomi     . 読み文字列)
;;      (okuri    . 送り文字列:一文字)
;;      (freq     . 頻度:回数)
;;   )
;;
(define (sumibi-lookup-candidate-bunsetu str query)
  (let* (
	 (hiragana (sumibi-roman->kana str))
	 (katakana (if hiragana
		       (romkan-hiragana->katakana hiragana)
		       #f))
	 (okuri-pattern-list (if hiragana
				 (sumibi-make-okurigana-pattern-list hiragana)
				 '()))
	 (strict-query 
	  (string-append
	   (format "(SELECT id, tango, yomi, okuri, freq_base FROM word WHERE (yomi = ~s AND okuri = '')) "  str)
	   (if hiragana
	       (format "UNION (SELECT id, tango, yomi, okuri, freq_base FROM word WHERE (yomi = ~s AND okuri = '')) " hiragana)
	       "")
	   (if katakana
	       (format "UNION (SELECT id, tango, yomi, okuri, freq_base FROM word WHERE (tango = ~s AND okuri = '')) " katakana)
	       "")))

	 ;; かなに直した読みでマッチングする。
	 ;; または 元の英語綴のままで直接マッチングする
	 (query-string
	  (string-append
	   strict-query
	   (if (> 1 (length okuri-pattern-list))
	       ""
	       (string-append
		"UNION (SELECT id, tango, yomi, word.okuri, word.freq_base FROM word RIGHT JOIN okuri USING ( okuri ) WHERE "
		(string-join
		 (map 
		  (lambda (x)
		    (format " (yomi = ~s AND okuri.okuri = ~s AND kana = ~s) " (car x) (cadr x) (caddr x)))
		  okuri-pattern-list)
		 " OR ")
		" ) "))
	   ))

	 (result
	  (map
	   (lambda (x)
	     `(
	       ,(list-ref x 0)
	       (tango    . ,(list-ref x 1))
	       (yomi     . ,(list-ref x 2))
	       (okuri    . ,(list-ref x 3))
	       (freq     . ,(list-ref x 4))))
	   (sumibi-select-query query 
				query-string
				"dsssd"
				))))

    (when sumibi-debug
	  (begin
	    (display (format "bunsetu = ~s" hiragana)) (newline)
	    (display (format "#search1# = ~s" query-string)) (newline)
	    (display "result1:")
	    (display result)
	    (newline)))
    `(
      (
       (orig     . ,str)
       (hiragana . ,hiragana)
       )
      ,result)))


;;
;; 3つのNgramの結果から評価値を求める
;;
(define (sumibi-compute-pacent result-bigram-pre2 result-bigram-pre1 result-word result-bigram-post1 result-bigram-post2)
  (let* (
	 (result
	 (map
	  (lambda (x)
	    (let* (
		   (id   (car x))
		   (data (cdr x))
		   (relative0 (cdr (assq 'relative0 data)))
		   (okuri     (cdr (assq 'okuri     data)))
		   (pre2  (assv id result-bigram-pre2))
		   (pre1  (assv id result-bigram-pre1))
		   (post1 (assv id result-bigram-post1))
		   (post2 (assv id result-bigram-post2))
		   (total
		    (+
		     (*
		      (list-ref sumibi-evaluate-balance 0)
		      (if pre2
			  (cdr (assq 'relative-2 (cdr pre2)))
			  0))
		     (*
		      (list-ref sumibi-evaluate-balance 1)
		      (if pre1
			  (cdr (assq 'relative-1 (cdr pre1)))
			  0))
		     (*
		      (list-ref sumibi-evaluate-balance 2)
		      relative0)
		     (*
		      (list-ref sumibi-evaluate-balance 3)
		      (if post1
			  (cdr (assq 'relative1 (cdr post1)))
			  0))
		     (*
		      (list-ref sumibi-evaluate-balance 4)
		      (if post2
			  (cdr (assq 'relative2 (cdr post2)))
			  0))))
		   ;; 送りがながある単語の評価を落とす
		   (total 
		    (if (< 0 (string-length okuri))
			(* total sumibi-evaluate-okurigana)
			total)))

	      (cons
	       id
	       (append data
		       (if pre1
			   (cdr pre1)
			   '((relative-1 . 0)))
		       (if pre2
			   (cdr pre2)
			   '((relative-2 . 0)))
		       (if post1
			   (cdr post1)
			   '((relative1 . 0)))
		       (if post2
			   (cdr post2)
			   '((relative2 . 0)))
		       `((total . ,total))))))

	  result-word))

	 ;; 結果を、評価値の高い順にソートする
	 (result
	  (sort result
		(lambda (x y)
		  (>
		   (cdr (assq 'total x))
		   (cdr (assq 'total y)))))))
    
    result))
	

;;
;; 前後に2連鎖した単語候補から、全組合せの共起確率を求める
;;
(define (sumibi-compute-candidate-pacent-sub rensa-bunsetu query)

  ;; 総あたりのwhere句を生成する
  (define (make-souatari-where-exp id-list1 id-list2)
    (if (null? id-list2)
	""
	(string-join
	 (map
	  (lambda (x)
	    (format " (id_base = ~d  AND  id_m1 = ~d) " (car x) (cadr x)))
	  (cartesian-product-right
	   (list
	    id-list1
	    id-list2)))
	 " OR ")))


  ;; 共起頻度を集計し％で結果を求める
  (define (exec-bigram-search-pre id-list table-name where-exp key debug-message query)
    (let* (
	   (sum-query-string
	    (string-append "SELECT SUM(freq_base) FROM " table-name " WHERE " where-exp))
	   (_
	    (if (null? id-list)
		'((1))
		(sumibi-select-query query 
				     sum-query-string
				     "d")))
	   (sum-str (number->string (caar _)))
	   
	   (bigram-query-string
	    (string-append
	     "    SELECT id_base, SUM( " table-name ".freq_base ), " sum-str ", SUM( " table-name ".freq_base )/ " sum-str " ,word.tango, okuri "
	     "      FROM " table-name " JOIN word ON id_base = word.id "
	     "      WHERE " where-exp
	     "    GROUP BY id_base ;"
	     ))
	   
	   (_
	    (when sumibi-debug
		  (begin
		    (display (format "~a = ~s" debug-message bigram-query-string)) (newline))))
	   
	   (result-bigram
	    (if (null? id-list)
		'()
		(map
		 (lambda (x)
		   `(
		     ,(list-ref x 0)
		     (freq1     . ,(list-ref x 1))
		     (sum1      . ,(list-ref x 2))
		     (,(string->symbol key) . ,(list-ref x 3))
		     (tango     . ,(list-ref x 4))
		     (okuri     . ,(list-ref x 5))))
		 (sumibi-select-query query 
				      bigram-query-string
				      "ddddss")))))))

  ;; 共起頻度を集計し％で結果を求める
  (define (exec-bigram-search-post id-list table-name where-exp key debug-message query)
    (let* (
	   (sum-query-string
	    (string-append "SELECT SUM(freq_base) FROM " table-name " WHERE " where-exp))
	   (_
	    (if (null? id-list)
		'((1))
		(sumibi-select-query query 
				     sum-query-string
				     "d")))
	   (sum-str (number->string (caar _)))
	   
	   (bigram-query-string
	    (string-append
	     "    SELECT id_m1, SUM( " table-name ".freq_base ), " sum-str ", SUM( " table-name ".freq_base )/ " sum-str " ,word.tango, okuri "
	     "      FROM " table-name " JOIN word ON id_m1 = word.id "
	     "      WHERE " where-exp
	     "    GROUP BY id_base ;"
	     ))
	   
	   (_
	    (when sumibi-debug
		  (begin
		    (display (format "~a = ~s" debug-message bigram-query-string)) (newline))))
	   
	   (result-bigram
	    (if (null? id-list)
		'()
		(map
		 (lambda (x)
		   `(
		     ,(list-ref x 0)
		     (freq1     . ,(list-ref x 1))
		     (sum1      . ,(list-ref x 2))
		     (,(string->symbol key) . ,(list-ref x 3))
		     (tango     . ,(list-ref x 4))
		     (okuri     . ,(list-ref x 5))))
		 (sumibi-select-query query 
				      bigram-query-string
				      "ddddss")))))))

  (let* (
	 ;; 二つ前の単語の候補ID
	 (id-list-pre2
	  (map
	   (lambda (x)
	     (car x))
	   (cadr (list-ref rensa-bunsetu 0))))

	 ;; 一つ前の単語の候補ID
	 (id-list-pre1
	  (map
	   (lambda (x)
	     (car x))
	   (cadr (list-ref rensa-bunsetu 1))))

	 ;; 注目位置の単語候補
	 (id-list
	  (map
	   (lambda (x)
	     (car  x))
	   (cadr (list-ref rensa-bunsetu 2))))

	 ;; 一つ後ろの単語の候補ID
	 (id-list-post1
	  (map
	   (lambda (x)
	     (car x))
	   (cadr (list-ref rensa-bunsetu 3))))

	 ;; 二つ後ろの単語の候補ID
	 (id-list-post2
	  (map
	   (lambda (x)
	     (car x))
	   (cadr (list-ref rensa-bunsetu 4))))


	 ;; 単語の候補IDを全て総あたり検索するWHERE句
	 (where-exp
	  (string-join
	   (map
	    (lambda (x)
	      (format " id = ~d " x))
	    id-list)
	   " OR "))
	 (where-exp-pre1
	  (make-souatari-where-exp
	   id-list id-list-pre1))
	 (where-exp-pre2
	  (make-souatari-where-exp
	   id-list id-list-pre2))
	 (where-exp-post1
	  (make-souatari-where-exp
	   id-list-post1 id-list))
	 (where-exp-post2
	  (make-souatari-where-exp
	   id-list-post2 id-list))

	 ;; 頻度総計を求める
	 (sum-query-string
	  (string-append "SELECT SUM(freq_base) FROM word WHERE " where-exp))
	 (_
	  (sumibi-select-query query 
			       sum-query-string
			       "d"))
	 (sum-str (number->string (caar _)))

	 (query-string
	  (string-append
	   "    SELECT id, tango, yomi, okuri, word.freq_base, " sum-str " ,word.freq_base / " sum-str " AS relative0 "
	   "      FROM word "
	   "      WHERE " where-exp 
	   ))

	 (_
	  (when sumibi-debug
		(begin
		  (display (format "#search2# = ~s" query-string)) (newline))))
		  
	 (result-word
	  (map
	   (lambda (x)
	     `(
	       ,(list-ref x 0)
	       (tango     . ,(list-ref x 1))
	       (yomi      . ,(list-ref x 2))
	       (okuri     . ,(list-ref x 3))
	       (freq0     . ,(list-ref x 4))
	       (sum0      . ,(list-ref x 5))
	       (relative0 . ,(list-ref x 6))))

	   (sumibi-select-query query 
				query-string
				"dsssddd")))


	 ;; 頻度総計を求める(pre1)
	 (result-bigram-pre1
	  (exec-bigram-search-pre id-list-pre1 "bigram" where-exp-pre1 "relative-1" "#search-pre1" query))

	 ;; 頻度総計を求める(pre2)
	 (result-bigram-pre2
	  (exec-bigram-search-pre id-list-pre2 "skip_bigram" where-exp-pre2 "relative-2" "#search-pre2" query))

	 ;; 頻度総計を求める(post1)
	 (result-bigram-post1
	  (exec-bigram-search-post id-list-post1 "bigram" where-exp-post1 "relative1" "#search-post1" query))

	 ;; 頻度総計を求める(post2)
	 (result-bigram-post2
	  (exec-bigram-search-post id-list-post2 "skip_bigram" where-exp-post2 "relative2" "#search-post2" query)))

    (when sumibi-debug
	  (begin
	    (display "result-pre2:")   (pretty-print result-bigram-pre2)   (newline)
	    (display "result-pre1:")   (pretty-print result-bigram-pre1)   (newline)
	    (display "result-base:")   (pretty-print result-word)          (newline)
	    (display "result-post1:")  (pretty-print result-bigram-post1)  (newline)
	    (display "result-post2:")  (pretty-print result-bigram-post2)  (newline)
	    ))

    (sumibi-compute-pacent
     result-bigram-pre2
     result-bigram-pre1
     result-word
     result-bigram-post1
     result-bigram-post2)))



;;
;; 前後に2連鎖した単語候補から、全組合せの共起確率を求める
;;
(define (sumibi-compute-candidate-pacent rensa-bunsetu query)
  (when sumibi-debug
	(begin
	  (display "#2#:")
	  (pretty-print rensa-bunsetu)
	  (newline)))
  (let* (
	;; 注目している単語の候補ID
	 (center(list-ref rensa-bunsetu 2))

	 (id-list
	  (map
	   (lambda (x)
	     (car x))
	   (cadr center))))

    (if (null? id-list)
	(begin
	  (if sumibi-debug
	      (begin
		(display "#kouho none#: ")
		(write (list-ref rensa-bunsetu 2))
		(newline)))
	  (list-ref rensa-bunsetu 2))
	
	;; 候補が存在するものについて実際に計算する
	`(
	  ,(car (list-ref rensa-bunsetu 2))
	  ,(sumibi-compute-candidate-pacent-sub rensa-bunsetu query)))))


;;
;; 変換候補リストを作成する
;;  連鎖する単語の評価値を求め、一番評価値の高い候補に並べる
;;
(define (sumibi-make-henkan-kouho kouho-list query)
  (let* (
	 ;; ダミーの文節データ
	 (dummy-bunsetu
	  '(
	    (
	     (orig     . #f)
	     (hiragana . #f))
	    (
	     (0 ;; id
	      (tango . "")
	      (yomi  . "")
	      (okuri . "")
	      (freq  . 0)
	      ))
	    ))

	 ;; スライドデータ1:先頭の単語の前にゼロ個ダミーを結合したもの
	 (kouho-list-pre0
	  (append
	   kouho-list
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)))

	 ;; スライドデータ1:先頭の単語の前に１つダミーを結合したもの
	 (kouho-list-pre1
	  (append
	   (list dummy-bunsetu)
	   kouho-list
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)))

	 ;; スライドデータ2:先頭の単語の前に２つダミーを結合したもの
	 (kouho-list-pre2
	  (append
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   kouho-list
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)))

	 ;; スライドデータ2:先頭の単語の前に３つダミーを結合したもの
	 (kouho-list-pre3
	  (append
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   kouho-list
	   (list dummy-bunsetu)))

	 ;; スライドデータ2:先頭の単語の前に４つダミーを結合したもの
	 (kouho-list-pre4
	  (append
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   (list dummy-bunsetu)
	   kouho-list))

	 ;; bigram, skip-bigram を使って可能性のある共起頻度を全パターン求める
	 (point-result
	  (map
	   (lambda (rensa-bunsetu)
	     (sumibi-compute-candidate-pacent rensa-bunsetu query))
	   (zip
	    kouho-list-pre4
	    kouho-list-pre3
	    kouho-list-pre2
	    kouho-list-pre1
	    kouho-list-pre0)))

	 ;; 前後 ２個づつの要素を削除する
	 (point-result
	  (take*
	   (drop* point-result 2)
	   (- (length point-result) 4))))

    (when sumibi-debug
	  (begin
	    (display "point-result:")
	    (pretty-print point-result)
	    (newline)))


    point-result))
	     

;;
;; 完成した文節を返す。
;;
(define (sumibi-output-henkan-kouho tango-info kouho-info)

  (define (is-kigou str)
    (not
     (rxmatch #/^[a-zA-Z0-9]+$/ str)))

  ;; 一番評価値の高い順に完成した文節を返す
  (map
   (lambda (x)
     (let (
	   (hiragana (cdr (assq 'hiragana tango-info)))
	   (orig     (cdr (assq 'orig tango-info)))
	   (tango    (cdr (assq 'tango   x)))
	   (okuri    (cdr (assq 'okuri   x)))
	   (yomi     (cdr (assq 'yomi    x))))
    
       (if (or hiragana (is-kigou orig))
	   (if (< 0 (string-length okuri))
	       (let ((okuri-string
		      (substring hiragana
				 (string-length yomi)
				 (+ (string-length yomi)
				    (- (string-length hiragana) (string-length yomi))))))
		 (string-append
		  tango
		  okuri-string))
	       tango)
	   orig)))
   kouho-info))


;;
;; 変換する。
;;  一番評価値の高い順に完成した文節を返す。
;;
(define (sumibi-output-henkan-kouho-list henkan-kouho-list)

  (map
   (lambda (bunsetu)
     (let (
	   ;; 単語情報
	   (tango-info (car  bunsetu))
	   (kouho-info (cadr bunsetu)))

       (when sumibi-debug
	     (begin
	       (display "#5#")
	       (write tango-info)
	       (newline)
	       (display "#6#")
	       (write kouho-info)
	       (newline)))

       (if (null? kouho-info)
	   ;; 候補なしの場合ユーザー入力文字列をそのまま返す
	   (let (
		 (hiragana (cdr (assq 'hiragana tango-info)))
		 (orig     (cdr (assq 'orig tango-info))))
	     (list 
	      (or hiragana orig)))

	   ;; 候補値の高い順に完成した文節を返す。
	   (sumibi-output-henkan-kouho tango-info kouho-info))))

   henkan-kouho-list))

	
;;
;; 文章文字列を変換する。
;;
(define (sumibi-convert-sentence str query)
  (let* (
	 ;; 文節リスト ( 一つ一つの文節は、全てローマ字のまま )
	 (bunsetu-list (string-split str #/\s+/))

	 (_
	  (when sumibi-debug
		(display "#0#")
		(write bunsetu-list)
		(newline)))

	 ;; 候補を検索する
	 (lookup-list
	  (map
	   (lambda (x)
	     (sumibi-lookup-candidate-bunsetu x query))
	   bunsetu-list))
	 (_
	  (when sumibi-debug
		(begin
		  (display "#1#")
		  (write lookup-list)
		  (newline))))

	 ;; 評価値順の候補リストを求める
	 (henkan-kouho-list (sumibi-make-henkan-kouho lookup-list query))
	 
	 ;; 変換候補リストを完成させて返す。
	 (complete-henkan-kouho-list (sumibi-output-henkan-kouho-list henkan-kouho-list)))

    ;; 結果を返す
    complete-henkan-kouho-list))


;; Main -------------------------------------------------------
(define (main args)

  (define docstrings
    `(
      ,(string-append "sumibi " sumibi-version)
      ""
      " Usage:"
      "	    sumibi [switches] [dictionary-file]"
      ""
      " Switches:"
      "     -h ... Display this help message."
      ))

  (define (display-help)
    (for-each
     (lambda (docstring)
       (print docstring))
     docstrings)
    (exit 4))

  (let* (
	 (command #f)

	 ;; Dropping the first argument.
	 (_ (cdr args))

	 ;; Checking switches.
	 (_ (parse-options
	     _
	     (
	      ("h" () (display-help)))))

	 (input-port
	  (open-input-string 
	   (port->string
	    (open-input-conversion-port
	     (current-input-port)
	     "*JP"
	     :buffer-size (* 10 1024)))))
   
	 (connection (dbi-make-connection driver 
					  sumibi-sumibidb-user
					  sumibi-sumibidb-password
					  sumibi-sumibidb-name))
	 (query (dbi-make-query connection))
	 )

    ;; analyze command line by line

    (if #f
	(begin
	  (sumibi-convert-sentence (car (port->string-list input-port)) query)))
    (for-each 
     (lambda (x)
       (let* ( 
	      (result (sumibi-convert-sentence x query))
	      (r
	       (string-join
		(map
		 (lambda (b)
		   (car b))
		 result)
		"/")))
	 #?=x
	 (display "#9#") (display x) (newline)
	 (display "#9#") (display r)   (newline)))
     (port->string-list input-port)))
  
  (exit 0))
